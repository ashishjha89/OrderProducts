# AWS EC2 (Single Instance) - Creation

## Expected outcome

- 1 EC2 instance
- Runs **all containers** (infra + services)
- ~4 GB RAM needed ‚Üí **must fit**
- Used **on-demand**, stopped when done
- **Lowest possible cost** without fighting OOM / crashes

## Calculate CPU and memory needs

- *Run locally all docker containers and find memory requirements*.
  - I see following usage:
    - 20% / 800% CPU (there are 8 CPUs available).
    - `3.8 GB container memory`.
    - *Note*: These are for running following containers:
      - mysql, mongodb, zookeeper, broker, connect, zipkin
      - disocvery-server, api-gateway, product-service, inventory-service, order-service
    - *Note*: These are with negligible traffic, just everything running idle.
    - *Note*: `Assume OS + Docker daemon` (~400‚Äì600 MB). Also, there will be memory spent for `Page cache + JVM overhead`.
    - *Note*: `Real memory requirements ~ 4.5 GB RAM`
  - Appropriate EC2 Instance Sizes:
    - `t3.large` which has 8GB RAM. (Note t2.medium has just 4 GB RAM).

## 1Ô∏è‚É£ Choose the right EC2 instance (most important decision)

### ‚úÖ Recommended instance

**`t3.large`**

| Resource         | Value          |
| ---------------- | -------------- |
| vCPU             | 2              |
| RAM              | **8 GB**       |
| Cost (eu-west-1) | ~‚Ç¨0.083 / hour |

### Why not smaller?

- Your containers already use **~4 GB**
- Add:
  - OS
  - Docker
  - JVM overhead
- `t3.medium (4 GB)` will **OOM eventually**
- `t3.large` gives safety + sanity

üí° **Cost reality**

- 15 minutes/day ‚Üí **~‚Ç¨1/month**
- This is already ‚Äúcheap enough‚Äù without pain

## 2Ô∏è‚É£ Launch EC2 (minimal setup)

### AMI

- **Amazon Linux 2023**

### Kay Value Pair

- Create a new key pair
  - Type: SSH key pair
  - Format: ed25519 (preferred) or RSA (fine)
  - Name: something explicit, e.g. orderproducts-ec2-key
- NOTE: AWS will download a .pem file once ‚Äî store it safely.

How you‚Äôll use it

```bash
chmod 400 orderproducts-ec2-key.pem
ssh -i orderproducts-ec2-key.pem ec2-user@<public-ip>
```

### Storage

- **20 GB gp3** (default is fine)
- No extra volumes
- No backups
- No snapshots needed

### Network

- Public subnet
- Auto-assign public IPv4 ‚Üí **Enabled**

### Security Group (minimal)

- Give a custom name (e.g. productproducts-ec2-sg)

- Inbound Rules:
  - SSH (22) ‚Üí source = your IP only
  - HTTP (8080) ‚Üí source = your IP only (for API Gateway)
  - SSH (22) -> source = com.amazonaws.eu-west-1.ec2-instance-connect (to allow SSA from AWS Console)

- Outbound Rules:
  - Allow all (this is enabled by default)

**How to get your IP:**
```bash
curl -4 ifconfig.me
# Example output: 203.0.113.42
# Use: 203.0.113.42/32 in security group
```

### CLI Command

CLI command to launch EC2 Instance

```bash
# CreateSecurityGroup
aws ec2 create-security-group --group-name 'orderproducts-ec2-sg' --description 'launch-wizard-1 created 2025-12-28T18:21:06.719Z' --vpc-id 'vpc-0d5b499d3d4094680' 

# AuthorizeSecurityGroupIngress
aws ec2 authorize-security-group-ingress --group-id 'sg-preview-1' --ip-permissions '{"IpProtocol":"tcp","FromPort":22,"ToPort":22,"IpRanges":[{"CidrIp":"89.99.47.2/32","Description":"SSH for admin and debug from My IP"}]}' '{"IpProtocol":"tcp","FromPort":8080,"ToPort":8080,"IpRanges":[{"CidrIp":"89.99.47.2/32","Description":"Access API Gateway port 8080 from My IP"}]}' 

# RunInstances 
aws ec2 run-instances --image-id 'ami-09c54d172e7aa3d9a' --instance-type 't3.large' --key-name 'orderproducts-ec2-key' --network-interfaces '{"AssociatePublicIpAddress":true,"DeviceIndex":0,"Groups":["sg-preview-1"]}' --credit-specification '{"CpuCredits":"unlimited"}' --tag-specifications '{"ResourceType":"instance","Tags":[{"Key":"Name","Value":"Order Products"}]}' --metadata-options '{"HttpEndpoint":"enabled","HttpPutResponseHopLimit":2,"HttpTokens":"required"}' --private-dns-name-options '{"HostnameType":"ip-name","EnableResourceNameDnsARecord":true,"EnableResourceNameDnsAAAARecord":false}' --count '1'
```

## 3Ô∏è‚É£ Install Docker & Docker Compose (once)

SSH into EC2:

```bash
# Update system
sudo dnf update -y

# Install Docker
sudo dnf install -y docker

# Start and enable Docker
sudo systemctl start docker
sudo systemctl enable docker

# Add ec2-user to docker group
sudo usermod -aG docker ec2-user

# Verify Docker installation
docker --version

exit
```

Reconnect (important).

Install compose plugin:

```bash
# Create plugin directory
sudo mkdir -p /usr/local/lib/docker/cli-plugins

# Download Docker Compose V2
sudo curl -SL https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-linux-x86_64 \
  -o /usr/local/lib/docker/cli-plugins/docker-compose

# Make executable
sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose

# Create symlink (optional, for backward compatibility)
sudo ln -sf /usr/local/lib/docker/cli-plugins/docker-compose /usr/local/bin/docker-compose

# Verify installation
docker compose version
```

## 4Ô∏è‚É£ Prepare your compose file for EC2 (important changes)

- Use images only (no build)

## 5Ô∏è‚É£ Reduce memory pressure (CRITICAL)

- Add memory limits per service (in docker-compose)
- This ensures:
  - No single container can kill the host
  - JVM respects limits (you already configured JVM flags)

## 6Ô∏è‚É£ Pull & start (daily workflow)

### First time (or after instance start)

- Install Git and clone project

```bash
# Install Git
sudo dnf install -y git

# Clone repository (replace with your GitHub username)
cd /home/ec2-user
git clone https://github.com/ashishjha89/OrderProducts.git
chown -R ec2-user:ec2-user OrderProducts

# Pull Docker images (as ec2-user)
cd OrderProducts/infrastructure/
docker compose pull

# Start containers
docker compose up -d
```

Wait ~1‚Äì2 minutes.

Verify:

```bash
docker ps
docker stats
```

---

## 7Ô∏è‚É£ When done practicing (MOST IMPORTANT)

### Stop everything

```bash
docker compose down -v
```

### Stop EC2

From AWS Console:

- **Stop instance**

üí∏ Cost now = **‚Ç¨0 while stopped**

---

## 8Ô∏è‚É£ Optional: fastest & cleanest teardown

If you‚Äôre done for the day:

- **Terminate instance**
- Relaunch tomorrow

Because:

- No persistence needed
- Everything is in images
- This avoids:

  - Disk costs
  - Zombie resources
  - Accidental spend

## 9Ô∏è‚É£ Cost guardrails (do this once)

### Create a budget

- ‚Ç¨10/month
- Alerts at 50%, 80%, 100%

### Enable cost anomaly detection

- Threshold: ‚Ç¨3‚Äì5

## Final daily routine (simple mental model)

### Start

1. Start EC2
2. `docker compose up -d`
3. Practice

### Stop

1. `docker compose down -v`
2. Stop EC2

## TL;DR

- ‚úÖ Use **t3.large**
- ‚úÖ No persistence
- ‚úÖ Images only
- ‚úÖ Memory limits
- ‚úÖ Stop or terminate daily
- ‚úÖ Cost ‚âà **‚Ç¨1‚Äì2/month**
